# Docker in Docker on Kubernetes

This example shows you how to run docker commands in container-native, CI pipeline on Kubernetes using the Argo workflow engine. 

But first, why would you want to run a Docker container from within a Docker container?

If you want to do Docker build in container native CI pipeline, you will need to use Docker in Docker or **Dind** because you will be calling Docker Build inside a workflow step which itself is a Docker container.


## Prerequisites
This example assumes the following:

* You have successfully [installed Argo on Kubernetes](https://argoproj.github.io/argo-site/get-started/installation).
* You have set your Kubernetes context to the correct cluster


## About the YAML Files

The Dind example workflow uses [sidecar-dind.yaml](https://github.com/argoproj/argo/blob/master/examples/sidecar-dind.yaml).

Docker-in-Docker works by running a Docker daemon inside a Docker container. The main requirement for DinD daemon is that it must not share the graph storage of the host's Docker daemon. Containers created with the DinD daemon are not visible to the host Docker daemon. 

To know more about **Dind Container** visit https://hub.docker.com/_/docker/

In this example we create a **Sidecar Dind container** that starts the Docker REST service on port 2375.

Setting the DOCKER_HOST to 127.0.0.1:2375 ensures that the Docker client in the main container (user workflow step) points to this Dind Docker daemon.


## Run Argo Sample Dind Workflow

### From Argo CLI:

```
$ argo2 submit ./sidecar-dind.yaml

```
Get the status of the running job:


```
$ argo get <job_name>

```

Get the logs of any step in the workflow

```
$ argo2 logs <step_name/podname>

```

### From Argo Web UI
1. You can see the workflow status in the Argo Web UI. You can also check the logs and artifacts generated by each step:

 ![CI-workflow](../..//images/ciworkflow.png)

